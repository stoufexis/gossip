package com.stoufexis.swim.programs

import zio.Chunk
import zio.prelude.fx.ZPure

import com.stoufexis.swim.SwimConfig
import com.stoufexis.swim.comms.*
import com.stoufexis.swim.model.*
import com.stoufexis.swim.model.Address.*
import com.stoufexis.swim.model.MessageType.*
import com.stoufexis.swim.programs.Pure.Output
import com.stoufexis.swim.tick.*
import com.stoufexis.swim.util.*

def sendMessageUnbounded(to: RemoteAddress, message: OutgoingMessage): Pure[Unit] =
  Pure.message(message.typ, to, Serde.encodeUnbounded(message))

def sendMessage(to: Iterable[RemoteAddress], message: OutgoingMessage): Pure[Unit] =
  for
    cfg               <- Pure.config
    (included, bytes) <- ZPure.succeed(Serde.encodeBounded(message, cfg.maxTransmissionUnit))
    _                 <- ZPure.foreach(to)(Pure.message(message.typ, _, bytes))
    _                 <- Pure.disseminated(included)
  yield ()

/** Note that when receiving a message that requires redirection a warning is logged, as it could indicate
  * partial system or networking failures.
  */
def handleMessages(messages: Chunk[IncomingMessage]): Pure[Unit] =
  def loop(msg: IncomingMessage): Pure[Unit] = Pure.get.flatMap: st =>
    if !st.isOperational(msg.from) then
      Pure.warning(Seq(msg.from), "Dropping message as it is from a non-operational member")
    else
      st.joiningVia match
        // Behavior when we are in the join process
        case Waiting.CurrentlyWaiting(joiningVia, _) =>
          // The only message we respond to is an expected joinAck directed at us
          msg match
            case TerminatingMessage(JoinAck, from, _, pl) if joiningVia == from =>
              Pure.info(Seq(msg.from), "Node confirmed out join")
                *> Pure.clearJoining
                *> Pure.append(pl)

            case _ =>
              Pure.info(Seq(msg.from), "Dropping message as we are still joining")

        // Behavior when we are not in the join process
        case _ =>
          msg match
            case RedirectMessage(_, from, to, _) if !st.isOperational(to) =>
              Pure.warning(
                Seq(from, to),
                s"Dropping redirect from $from to $to as the receiver is not an operational member"
              )

            // We do not check if the message fits into the mtu limit, as the limit would have been applied by the sending node
            // We also do not include the addresses in the payload into our own counters, as they were not generated by us
            case msg @ RedirectMessage(_, from, to, pl) =>
              Pure.warning(Seq(from, to), s"Redirecting message from $from to $to")
                *> sendMessageUnbounded(to, msg)
                *> Pure.append(pl)

            case TerminatingMessage(Ping, from, _, pl) =>
              for
                cfg     <- Pure.config
                _       <- Pure.info(Seq(from), "Acking ping")
                updates <- Pure.appendAndGet(pl)
                _       <- sendMessage(List(from), InitiatingMessage(Ack, cfg.address, from, updates))
              yield ()

            case TerminatingMessage(Ack, from, _, pl) if st.waitingOnAck.currentlyWaitingFor(from) =>
              Pure.info(Seq(from), "Received valid ack")
                *> Pure.clearWaitingOnAck
                *> Pure.append(pl)

            // This message is likely old, so we dont accept its payload to guard against stale information
            case TerminatingMessage(Ack, from, _, _) =>
              Pure.warning(Seq(from), "Dropping unexpected ack")

            case TerminatingMessage(Join, from, _, pl) =>
              for
                cfg <- Pure.config
                us  <- Pure.updates
                _   <- Pure.info(Seq(from), "Node is joining the cluster")
                _   <- ZPure.when(pl.nonEmpty)(Pure.warning(Seq(from), "Dropping Join payload"))
                _   <- sendMessage(List(from), InitiatingMessage(JoinAck, cfg.address, from, us))
              yield ()

            // This message is likely old, so we dont accept its payload to guard against stale information
            case TerminatingMessage(JoinAck, from, _, _) =>
              Pure.warning(Seq(from), "Received unexpected join ack")

  ZPure.foreachDiscard(messages)(loop)

def pingRandomMember: Pure[Unit] =
  Pure.getOperational.map(NonEmptySet(_)).flatMap:
    case Some(addresses) =>
      for
        cfg    <- Pure.config
        target <- Pure.randomElem(addresses)
        us     <- Pure.updates
        _      <- Pure.setWaitingOnAck(target)
        _      <- sendMessage(List(target), InitiatingMessage(Ping, cfg.address, target, us))
      yield ()

    case None =>
      Pure.info(msg = "No-one to ping") *> Pure.clearWaitingOnAck

def pingIndirectly(target: RemoteAddress): Pure[Unit] =
  Pure.getOperationalWithout(target).map(NonEmptySet(_)).flatMap:
    case Some(s) =>
      for
        cfg     <- Pure.config
        us      <- Pure.updates
        targets <- Pure.randomElems(s, cfg.failureDetectionSubgroupSize)
        _       <- Pure.warning(target :: List.from(targets), s"Pinging $target indirectly through $targets")
        _       <- sendMessage(targets, InitiatingMessage(Ping, cfg.address, target, us))
      yield ()

    // TODO: Re-ping target directly when there are no indirect targets available
    case None =>
      Pure.warning(Seq(target), "No indirect targets for member")

/** Send a join to one of the provided seed nodes, excluding the given tryExclude node. If after excluding
  * `tryExclude` the seedNodes are empty, the `tryExclude` address is contacted instead.
  */
def sendJoin(tryExclude: Option[RemoteAddress] = None): Pure[Unit] =
  for
    cfg <- Pure.config

    target: RemoteAddress <- tryExclude match
      case Some(e) => NonEmptySet(cfg.seedNodes - e).fold(ZPure.succeed(e))(Pure.randomElem)
      case None    => Pure.randomElem(cfg.seedNodes)

    _ <- Pure.info(Seq(target), "Joining through existing member")
    // There is no payload, so the bound does not apply
    _ <- sendMessageUnbounded(target, InitiatingMessage(Join, cfg.address, target, Chunk()))
    _ <- Pure.setJoining(target)
  yield ()

def sendPings: Pure[Unit] =
  for
    (st, tick, cfg) <- Pure.inputs

    _ <- st.waitingOnAck match
      // We are not waiting for any ack and a ping period passed. Ping another member.
      case Waiting.LastWaited(lastPing) if tick - lastPing > cfg.pingPeriodTicks =>
        pingRandomMember

      // Its not yet time to ping again
      case Waiting.LastWaited(_) =>
        ZPure.unit

      // Ping period passed and we have not received an ack from the pinged member - they are looking kinda sus.
      case Waiting.CurrentlyWaiting(waitingOn, lastPing) if tick - lastPing > cfg.pingPeriodTicks =>
        Pure.warning(Seq(waitingOn), "Ping period expired. Marking member as suspicious")
          *> Pure.setSuspicious(waitingOn)
          *> pingRandomMember

      // Direct ping period passed and we have not received an ack for the pinged member - ping indirectly.
      case Waiting.CurrentlyWaiting(waitingOn, lastPing) if tick - lastPing > cfg.directPingPeriodTicks =>
        Pure.warning(Seq(waitingOn), "Direct ping period expired for member")
          *> pingIndirectly(waitingOn)

      // No period has expired
      case _: Waiting.CurrentlyWaiting =>
        ZPure.unit

      // We just started up, as there is no previous ping. Ping immediatelly
      case Waiting.NeverWaited =>
        pingRandomMember
  yield ()

def detectFailures: Pure[Unit] =
  for
    (_, tick, cfg) <- Pure.inputs
    failed         <- Pure.modify(_.updateOverdueSuspicious(tick - cfg.suspectedPeriodTicks, tick))
    _ <- ZPure.when(failed.nonEmpty)(Pure.warning(failed.toSeq,"Found failed members"))
  yield ()

def handleTimeouts: Pure[Unit] =
  for
    (st, tick, cfg) <- Pure.inputs

    _ <- st.joiningVia match
      // We are not in the joining process anymore, we begin pinging after a ping period from our last join message
      case _: Waiting.LastWaited => detectFailures *> sendPings

      // We are currently in the join process and the join timeout has been exceeded. Pick a different seed node
      case Waiting.CurrentlyWaiting(joiningVia, attemptedAt) if tick - attemptedAt > cfg.joinPeriodTicks =>
        sendJoin(tryExclude = Some(joiningVia))

      // We are currently in the join process and the join timeout has not been exceeded
      case _: Waiting.CurrentlyWaiting => ZPure.unit

      // We have just startup up, so we have never attempted to join
      case Waiting.NeverWaited => sendJoin()
  yield ()

/** All the logic that runs in a single tick
  */
def singleIteration(
  cfg:      SwimConfig,
  ts:       Ticks,
  st:       State,
  rand:     PseudoRandom,
  messages: Chunk[IncomingMessage]
): (Chunk[Output], State, PseudoRandom) =
  val program           = handleMessages(messages) *> handleTimeouts
  val env               = zio.ZEnvironment(cfg, ts)
  val (outs, res)       = program.provideEnvironment(env).runAll((st, rand))
  val ((st1, rand1), _) = res.right.get
  (outs, st1, rand1)
